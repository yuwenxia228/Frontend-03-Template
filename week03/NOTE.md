学习笔记<br>
获得了服务器返回的html信息后，对html文件进行解析，构建dom树。<br>
首先，还是利用状态机的方法，根据不同的状态，处理不同的事情，<br>
<:开始标签，进去tagOpen状态<br>
tagOpen:如果是普通字符进入tagName状态，'/'进入endTagOpen状态<br>
tagName:普通字符保存起来，作为标签名字的一部分，遇到空白符进入beforeattributeName.遇到'/'进入selfClosingStartTag（自封闭标签），遇到‘>’则结束标签，发送一个token<br>
beforeAttributeName:遇到普通字符进入attributeName并传递当前字符，遇到空白符仍然保持当前状态，遇到‘/’或‘>’进入afterAttributeName状态<br>
attributeName:遇到普通字符保存起来作为属性名，遇到‘=’进入beforeAttributeValue状态<br>
beforeAttributeValue:空白符当前状态，分为双引号、单引号、无引号三种状态处理<br>
doubleQuotedAttributeValue、singleQuotedAttributValue、unQuotedAttributeValue三种状态处理相似，分别遇到第二个”，’，空白符则结束该状态进入after状态，普通字符则保存为属性值<br>
afterQuotedAttributeValue:空白符继续beforeAttributeName，‘/’selfClosingStartTag，‘>’发送token<br>
selfClosingStartTag:‘>’结束标签，设置isSelfClosing属性为true，发送token<br>
根据token进行入栈和出栈操作，最后dom树就构建成功了。<br>》
css规则的收集在style标签入栈之后的文本节点入栈是发生，利用css包完成。规则收集完成之后，在每一个元素入栈是都会跟css规则进行匹配。匹配过程如下:将css规则中的选择器变成数组并倒序，与当前栈中的元素从内到外进行比较，相等则继续进行外层比较，逐层匹配，最后选择器全部匹配完则此条规则与该元素匹配成功，然后再看优先级，如果优先级不存在则直接保存规则内容，否则比较优先级，优先级较高的才能覆盖原规则。根据这个方法依次解析所有元素，包含css的dom树就构建成功了。
